input -> length_of_list
input -> num_qubits
input -> num_terms
increment idx to length_of_list
    input -> unparsed_hamiltonian.[idx]
next

0.1 -> epsilon

increment idx to 2 * num_terms
    0 -> measurement_outcomes.[idx]
next

qubit -> ancilla

increment qubit_idx to num_qubits
    qubit -> sys_qubits.[qubit_idx]
next

1 -> main_loop_cutoff
increment main_loop_counter to main_loop_cutoff
    gosub weak_measurement
next

sub weak_measurement
    increment term_idx to 2 * num_terms
        gosub weak_measurement_term
    next
endsub

sub basis_change
    increment qubit_idx to num_qubits
    
    next
endsub

sub weak_measurement_term
    coeff.[term_idx] -> phi
    phi -> angle_1
    phi - theta / 2 -> angle_2
    theta - phi / 2 -> angle_3
    # first ancilla rotation
    ry[ancilla, angle_1]
    
    # change basis
    gosub basis_change
    
    # First round of cnots
    increment control_qubit to num_qubits
        cnot[sys_qubits.[control_qubit], ancilla]
    next
    
    # second rotation
    ry[ancilla, angle_2]
    
    # second round of cnots
    increment control_qubit to num_qubits
        cnot[sys_qubits.[num_qubits - control_qubits + 1], ancilla]
    next
    
    # third rotation
    ry[ancilla, angle_3]
    
    # change basis back
    goinv basis_change 
    
endsub
